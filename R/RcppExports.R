# Generated by using Rcpp::compileAttributes() -> do not edit by hand
# Generator token: 10BE3573-1514-4C36-9D1C-5A225CD40393

#' Calculating the sum of a vector
#'
#' This function calculates the sum of a given vector.
#'
#' @param v A numeric vector.
#' @return The sum of the elements in the vector.
#'
#'@export
SumL <- function(v) {
    .Call('_operap_SumL', PACKAGE = 'operap', v)
}

#' Calculating the minimum of a vector
#'
#' This function calculates the minimum value of a given vector.
#'
#' @param v A numeric vector.
#' @return The minimum value in the vector.
#'
#'@export
getMin <- function(v) {
    .Call('_operap_getMin', PACKAGE = 'operap', v)
}

#' C++ function to call the R function [quadprog::solve.QP()]
#'
#' This function serves as a bridge between C++ and R, allowing you to call the R function [quadprog::solve.QP()] from C++ code.
#'
#' @param Dmat A matrix appearing in the quadratic function to be minimized.
#' @param dvec A vector appearing in the quadratic function to be minimized.
#' @param Amat A matrix defining the constraints under which we want to minimize the quadratic function.
#'
#' @seealso [quadprog::solve.QP()]
#'
#' @return A list containing the solution obtained from the R function [quadprog::solve.QP()].
#'@export
quadprogSolveR <- function(Dmat, dvec, Amat) {
    .Call('_operap_quadprogSolveR', PACKAGE = 'operap', Dmat, dvec, Amat)
}

#' Perform Special Summation Over Risk Sets
#'
#' This function calculates a special summation over risk sets based on given parameters.
#'
#' @param indset The index matrix of the risk set.
#' @param value_vec The values to be summed over. In our problem, it represents the exponential of eta.
#' @param ind_vec The vector indicating the failure times to be summed over.
#' @param p The power number.
#'
#' @export
sum_risk <- function(indset, value_vec, ind_vec, p) {
    .Call('_operap_sum_risk', PACKAGE = 'operap', indset, value_vec, ind_vec, p)
}

#' Calculate Negative Log Partial Likelihood
#'
#' This function calculates the negative log partial likelihood based on the given parameters.
#'
#' @param X The design matrix.
#' @param indset The risk set matrix.
#' @param beta The vector of coefficients.
#' @param cen The vector of censoring indicators or binary outcomes.
#' @param y The vector of times to failure or binary outcomes.
#' @param type The type of outcome, either "surv" for survival outcome or "bin" for binary outcome.
#'
#' @return The negative log partial likelihood.
#'@export
logPL_C <- function(X, indset, cen, y, beta, type = "surv") {
    .Call('_operap_logPL_C', PACKAGE = 'operap', X, indset, cen, y, beta, type)
}

#' Perform Iterative Solution of Group Fused Lasso Penalty
#'
#' This function performs the iterative solution of the group fused lasso penalty based on the given parameters.
#'
#' @param Dmat0 The original quadratic term matrix.
#' @param dvec0 The original linear term vector.
#' @param Apo The partial order matrix.
#' @param lambda The tuning parameter.
#' @param nb The number of boundaries.
#' @param w The weights.
#' @param inibeta The initial beta value for warm start.
#' @param maxiter The maximum number of iterations.
#' @param eps The tolerance number.
#' @param trace Whether to trace each iteration output.
#'
#' @return The solution beta.
#'@export
iter_pen <- function(Dmat0, dvec0, Apo, lambda, w, nb, inibeta, maxiter, eps, trace = FALSE) {
    .Call('_operap_iter_pen', PACKAGE = 'operap', Dmat0, dvec0, Apo, lambda, w, nb, inibeta, maxiter, eps, trace)
}

#' Calculate Value of Penalty Term
#'
#' This function calculates the value of the penalty term based on the given parameters.
#'
#' @param Apo The partial order matrix.
#' @param w The adaptive parameter.
#' @param nb The number of boundaries
#' @param beta The vector of coefficients.
#'
#' @return The value of the penalty term.
#'@export
val_pen <- function(Apo, w, nb, beta) {
    .Call('_operap_val_pen', PACKAGE = 'operap', Apo, w, nb, beta)
}

#' Round Close Values to the Same
#'
#' This function rounds close values in a vector to the same value based on a given tolerance.
#'
#' @param beta The vector of coefficients.
#' @param eps The tolerance for rounding.
#'@export
roundvec <- function(beta, eps) {
    .Call('_operap_roundvec', PACKAGE = 'operap', beta, eps)
}

#' Calculate the best coefficients using lasso tree method without parameter tuning
#'
#' This function calculates the best coefficients using lasso tree method without parameter tuning
#'
#' @param X The design matrix.
#' @param indset The risk set.
#' @param Apo The partial ordering matrix.
#' @param nb The number of boundaries.
#' @param cen The vector of censoring indicators or binary outcomes.
#' @param y The vector of times to failure or binary outcomes.
#' @param type The type of outcome, either "surv" for survival outcome or "bin" for binary outcome.
#' @param w The adaptive parameter.
#' @param inibeta The initial beta value for warm start.
#' @param lambda The tuning parameter.
#' @param maxiter The maximum number of iterations.
#' @param eps The tolerance number.
#' @param fullA Boolean variable indicating whether to calculate all elements of the Hessian.
#' @param trace Whether to trace each iteration output.
#'
#' @return A vector of the solution beta.
#'@export
lasso_tree_single <- function(X, indset, Apo, nb, w, cen, y, lambda, inibeta, maxiter, eps, trace, fullA = FALSE, type = "surv") {
    .Call('_operap_lasso_tree_single', PACKAGE = 'operap', X, indset, Apo, nb, w, cen, y, lambda, inibeta, maxiter, eps, trace, fullA, type)
}

#' Calculate Best Coefficients using Lasso Tree Method with Parameter Tuning
#'
#' This function calculates the best coefficients using the lasso tree method with parameter tuning.
#'
#' @param X The design matrix.
#' @param indset The risk set.
#' @param Apo The partial ordering matrix.
#' @param nb The number of boundaries.
#' @param cen The vector of censoring indicators or binary outcomes.
#' @param y The vector of times to failure or binary outcomes.
#' @param type The type of outcome, either "surv" for survival outcome or "bin" for binary outcome.
#' @param w The adaptive parameter.
#' @param inibeta The initial beta value for warm start.
#' @param lambda The tuning parameters.
#' @param maxiter The maximum number of iterations.
#' @param eps The tolerance number.
#' @param fullA Boolean variable indicating whether to calculate all elements of the Hessian.
#' @param trace Whether to trace each iteration output.
#'
#' @return A numeric matrix with the first column representing the values of lambda and the remaining columns representing the corresponding coefficients.
#'@export
lasso_tree_multi <- function(X, indset, Apo, nb, w, cen, y, lambda, inibeta, maxiter, eps, trace, type = "surv", fullA = FALSE) {
    .Call('_operap_lasso_tree_multi', PACKAGE = 'operap', X, indset, Apo, nb, w, cen, y, lambda, inibeta, maxiter, eps, trace, type, fullA)
}

#' C++ function to call the R function [quadprog::solve.QP()]
#'
#' This function serves as a bridge between C++ and R, allowing you to call the R function [quadprog::solve.QP()] from C++ code.
#'
#' @param Dmat A matrix appearing in the quadratic function to be minimized.
#' @param dvec A vector appearing in the quadratic function to be minimized.
#' @param Amat A matrix defining the constraints under which we want to minimize the quadratic function.
#'
#' @seealso [quadprog::solve.QP()]
#'
#' @return A list containing the solution obtained from the R function [quadprog::solve.QP()].
#'@export
quadprog_solveR <- function(Dmat, dvec, Amat, bvec) {
    .Call('_operap_quadprog_solveR', PACKAGE = 'operap', Dmat, dvec, Amat, bvec)
}

#' Call R Function to Compute Eigenvalues and Eigenvectors
#'
#' This C++ function calls an R function to compute the eigenvalues and eigenvectors of a numeric (double, integer, logical) or complex matrix.
#'
#' @param mat An approximately positive definite matrix.
#' @return A list containing the eigenvalues and eigenvectors.
#'
#'@export
ED <- function(mat) {
    .Call('_operap_ED', PACKAGE = 'operap', mat)
}

#' Replace Negative Values with Zeros in a Vector
#'
#' This function replaces all the negative values of a vector with zeros.
#'
#' @param v A numeric vector.
#' @return The non-negative version of the vector.
#'
#'@export
nNv <- function(v) {
    .Call('_operap_nNv', PACKAGE = 'operap', v)
}

#' Compute Nearest Positive Definite Matrix
#'
#' This function computes the nearest positive definite matrix to an approximately positive definite matrix.
#'
#' @param mat An approximately positive definite matrix.
#'
#' @return The nearest positive definite matrix.
#'
#'@export
CnearPD <- function(mat) {
    .Call('_operap_CnearPD', PACKAGE = 'operap', mat)
}

#' Calculate Sum of Vector Elements
#'
#' This function calculates the sum of elements in a given vector.
#'
#' @param v A vector.
#' @return The sum of the vector elements.
#'
#'@export
Sum <- function(v) {
    .Call('_operap_Sum', PACKAGE = 'operap', v)
}

#' Calculate Minimum of Vector Elements
#'
#' This function calculates the minimum value among the elements of a given vector.
#'
#' @param v A vector.
#' @return The minimum value of the vector elements.
#'
#'@export
Min <- function(v) {
    .Call('_operap_Min', PACKAGE = 'operap', v)
}

#' Check for Inf or NaN in Vector
#'
#' This function checks whether a given vector contains any elements that are either Inf (infinity) or NaN (not-a-number).
#'
#' @param v A vector.
#' @return A boolean value indicating whether the vector contains Inf or NaN.
#'
#'@export
wInf <- function(v) {
    .Call('_operap_wInf', PACKAGE = 'operap', v)
}

#' Round Vector Elements
#'
#' This function rounds the elements of a given vector to the nearest integer, based on a specified threshold.
#'
#' @param v A vector.
#' @param eps A small number representing the rounding threshold.
#' @return A vector with rounded elements.
#'
#'@export
Round <- function(v, eps) {
    .Call('_operap_Round', PACKAGE = 'operap', v, eps)
}

#' Count Non-Zero Distinct Values in Vector
#'
#' This function calculates the number of non-zero distinct values in a given vector.
#'
#' @param v A vector.
#' @return The number of non-zero distinct values in the vector.
#'
#'@export
countDistinct <- function(v) {
    .Call('_operap_countDistinct', PACKAGE = 'operap', v)
}

#' Calculate Cumulative Sums of Vector Elements
#'
#' This function calculates the cumulative sums of elements in a given vector.
#'
#' @param v A vector.
#' @return A vector containing the cumulative sums of the input vector.
#'
#'@export
cumSum <- function(v) {
    .Call('_operap_cumSum', PACKAGE = 'operap', v)
}

#' Calculate Reverse Cumulative Sums of Vector Elements
#'
#' This function calculates the reverse cumulative sums of elements in a given vector.
#'
#' @param v A vector.
#' @return A vector containing the reverse cumulative sums of the input vector.
#'
#'@export
revCumSum <- function(v) {
    .Call('_operap_revCumSum', PACKAGE = 'operap', v)
}

#' Create Equally-Spaced Logarithmic Sequence
#'
#' This function creates an equally-spaced sequence in the log scale, also known as a geometric series, between a starting value and an ending value.
#'
#' @param a A numeric value representing the starting value.
#' @param b A numeric value representing the ending value.
#' @param c The length of the sequence.
#' @return An equally-spaced sequence in the log scale (a geometric series).
#'
#'@export
gs <- function(a, b, c = 30L) {
    .Call('_operap_gs', PACKAGE = 'operap', a, b, c)
}

#' Calculate Negative Log (Partial) Likelihood
#'
#' This function calculates the negative log (partial) likelihood based on the given parameters.
#'
#' @param Z A matrix of nodes.
#' @param cen A vector of censoring statuses or binary outcomes.
#' @param beta A vector of node coefficients.
#' @param y A vector of outcomes.
#' @param withCov Whether any covariates need adjusting.
#' @param cov A matrix of covariates.
#' @param theta A vector of covariate coefficients.
#' @param type A string indicating the type of outcome, currently either "survival" or "binary".
#'
#' @return The negative log likelihood.
#'
#'@export
logLK <- function(Z, cen, beta, y, cov, theta, type = "surv", withCov = FALSE) {
    .Call('_operap_logLK', PACKAGE = 'operap', Z, cen, beta, y, cov, theta, type, withCov)
}

#' Calculate First and Second Derivatives of Log (Partial) Likelihood
#'
#' This function calculates the first and second derivatives of the log (partial) likelihood based on the given parameters.
#'
#' @param Z A matrix of nodes.
#' @param cen A vector of censoring statuses or binary outcomes.
#' @param beta A vector of node coefficients.
#' @param y A vector of outcomes.
#' @param cov Covariates.
#' @param theta Covariate coefficients.
#' @param withCov Whether any covariates need adjusting.
#' @param type A string indicating the type of outcome, currently either "survival" or "binary".
#' @param seed The seed used for generating the simulation dataset.
#' @return A list of derivatives.
#'
#'@export
derivatives <- function(Z, cen, beta, y, cov, theta, seed, withCov = FALSE, type = "surv") {
    .Call('_operap_derivatives', PACKAGE = 'operap', Z, cen, beta, y, cov, theta, seed, withCov, type)
}

#' Perform One Iteration of Iterative Re-weighted Least Squares
#'
#' This function performs one iteration of the Iterative Re-weighted Least Squares (IRLS) algorithm based on the given parameters.
#'
#' @param coeff0 Current coefficients for nodes.
#' @param theta0 Current coefficients for covariates that need adjusting.
#' @param cen A vector of censoring statuses or binary outcomes
#' @param y A vector of outcomes.
#' @param Z A matrix of nodes.
#' @param cov A matrix of covariates.
#' @param Cnstrn A matrix of partial ordering constraints.
#' @param coeffLambda A numeric value of the tuning parameter lambda.
#' @param seed The seed used for generating the simulation dataset.
#' @param withCov Whether any covariates need adjusting.
#' @param type A string indicating the type of outcome, either "survival" or "binary".
#'
#' @return A vector of coefficients at the next iteration.
#'
#'@export
IRLSO <- function(coeff0, theta0, cen, y, Z, cov, Cnstrn, coeffLambda, seed = 0L, withCov = FALSE, type = "surv") {
    .Call('_operap_IRLSO', PACKAGE = 'operap', coeff0, theta0, cen, y, Z, cov, Cnstrn, coeffLambda, seed, withCov, type)
}

#' Iterative Re-weighted Least Squares: All Iterations
#'
#' This function performs all iterations of the Iterative Re-weighted Least Squares (IRLS) algorithm to obtain the Maximum Likelihood Estimates (MLEs) based on the given parameters.
#'
#' @param coeff A vector of initial coefficients for nodes.
#' @param theta A vector of initial coefficients for covariates that need adjusting.
#' @param cen A vector of censoring statuses or binary outcomes.
#' @param y A vector of outcomes.
#' @param Z A matrix of nodes.
#' @param cov A matrix of covariates.
#' @param Cnstrn A matrix of constraints.
#' @param coeffLambda A vector of tuning parameter lambda.
#' @param eps A numeric value denoting the accuracy level.
#' @param maxiter An integer denoting the maximum number of iterations to obtain the MLEs.
#' @param seed The seed used for generating the simulation dataset.
#' @param withCov Whether any covariates need adjusting.
#' @param type A string denoting the outcome type, either "survival" or "binary" outcome.
#' @return The estimates
#'
#'@export
IRLSA <- function(coeff, theta, cen, y, Z, cov, Cnstrn, coeffLambda, eps = 0.0001, maxiter = 10L, seed = 0L, withCov = FALSE, type = "surv") {
    .Call('_operap_IRLSA', PACKAGE = 'operap', coeff, theta, cen, y, Z, cov, Cnstrn, coeffLambda, eps, maxiter, seed, withCov, type)
}

#' Perform One Iteration of Iterative Re-weighted Least Squares in the Pruning Step
#'
#' This function performs one iteration of the Iterative Re-weighted Least Squares (IRLS) algorithm in the pruning step based on the given parameters.
#'
#' @param coeff0 Current coefficients for nodes.
#' @param theta0 Current coefficients for covariates that need adjusting.
#' @param cen A vector of censoring statuses or binary outcomes.
#' @param y A vector of outcomes.
#' @param Z A matrix of nodes.
#' @param cov A matrix of covariates.
#' @param LCnstrn A matrix of linear partial ordering constraints.
#' @param qCnstrn A matrix of quadratic constraints.
#' @param mCnstrn An integer denoting how many more constraints are needed.
#' @param minCoeff The lower bound for all the coefficients.
#' @param maxCoeff The upper bound for all the coefficients.
#' @param Lambda A numeric value of the tuning parameter lambda to enforce the quadratic constraints.
#' @param withCov Whether any covariates need adjusting.
#' @param seed The seed used for generating the simulation dataset.
#' @param type A string indicating the type of outcome, either "survival" or "binary" outcome.
#' @return A vector of coefficients at the next iteration.
#'
#'@export
IRLSP <- function(coeff0, theta0, cen, y, Z, cov, LCnstrn, qCnstrn, mCnstrn, minCoeff, maxCoeff, Lambda, withCov = FALSE, seed = 0L, type = "surv") {
    .Call('_operap_IRLSP', PACKAGE = 'operap', coeff0, theta0, cen, y, Z, cov, LCnstrn, qCnstrn, mCnstrn, minCoeff, maxCoeff, Lambda, withCov, seed, type)
}

#' Perform Parameter Tuning for Each Iteration of Iterative Re-weighted Least Squares in the Pruning Step
#'
#' This function performs parameter tuning for each iteration of the Iterative Re-weighted Least Squares (IRLS) algorithm in the pruning step based on the given parameters.
#'
#' @param coeff A vector of initial coefficients for nodes.
#' @param theta A vector of initial coefficients for covariates that need adjusting.
#' @param cen A vector of censoring statuses or binary outcomes.
#' @param y A vector of outcomes.
#' @param Z A matrix of nodes.
#' @param cov A matrix of covariates.
#' @param LCnstrn A matrix of linear partial ordering constraints.
#' @param qCnstrn A matrix of quadratic constraints.
#' @param mCnstrn An integer denoting how many more constraints are needed.
#' @param minCoeff The lower bound for all the coefficients.
#' @param maxCoeff The upper bound for all the coefficients.
#' @param eps A numeric value denoting the accuracy level.
#' @param maxiter An integer denoting the maximum number of iterations.
#' @param withCov Whether any covariates need adjusting.
#' @param seed The seed used for generating the simulation dataset.
#' @param type A string indicating the type of outcome, either "survival" or "binary" outcome.
#' @return The coefficients after tuning the parameter.
#'
#'@export
IRLSPT <- function(coeff, theta, cen, y, Z, cov, LCnstrn, qCnstrn, mCnstrn, minCoeff, maxCoeff, eps = 0.0001, maxiter = 10L, withCov = FALSE, seed = 0L, type = "surv") {
    .Call('_operap_IRLSPT', PACKAGE = 'operap', coeff, theta, cen, y, Z, cov, LCnstrn, qCnstrn, mCnstrn, minCoeff, maxCoeff, eps, maxiter, withCov, seed, type)
}

#' Perform All Iterations of Iterative Re-weighted Least Squares in the Pruning Step
#'
#' This function performs all iterations of the Iterative Re-weighted Least Squares (IRLS) algorithm in the pruning step based on the given parameters.
#'
#' @param coeff A vector of initial coefficients for nodes.
#' @param theta A vector of initial coefficients for covariates that need adjusting.
#' @param cen A vector of censoring statuses or binary outcomes.
#' @param y A vector of outcomes.
#' @param Z A matrix of nodes.
#' @param cov A matrix of covariates.
#' @param LCnstrn A matrix of linear partial ordering constraints.
#' @param qCnstrn A matrix of quadratic constraints.
#' @param mCnstrn An integer denoting how many more constraints are needed.
#' @param eps A numeric value denoting the accuracy level.
#' @param minCoeff The lower bound for all the coefficients.
#' @param maxCoeff The upper bound for all the coefficients.
#' @param maxiter An integer denoting the maximum number of iterations.
#' @param withCov Whether any covariates need adjusting.
#' @param seed The seed used for generating the simulation dataset.
#' @param type A string indicating the type of outcome, either "survival" or "binary" outcome.
#' @return The coefficients under the tuning parameter after several iterations.
#'
#'@export
IRLSPAT <- function(coeff, theta, cen, y, Z, cov, LCnstrn, qCnstrn, mCnstrn, minCoeff, maxCoeff, eps = 0.0001, maxiter = 10L, withCov = FALSE, seed = 0L, type = "surv") {
    .Call('_operap_IRLSPAT', PACKAGE = 'operap', coeff, theta, cen, y, Z, cov, LCnstrn, qCnstrn, mCnstrn, minCoeff, maxCoeff, eps, maxiter, withCov, seed, type)
}

